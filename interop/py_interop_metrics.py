# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_py_interop_metrics')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_py_interop_metrics')
    _py_interop_metrics = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_py_interop_metrics', [dirname(__file__)])
        except ImportError:
            import _py_interop_metrics
            return _py_interop_metrics
        try:
            _mod = imp.load_module('_py_interop_metrics', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _py_interop_metrics = swig_import_helper()
    del swig_import_helper
else:
    import _py_interop_metrics
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _py_interop_metrics.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _py_interop_metrics.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _py_interop_metrics.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _py_interop_metrics.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _py_interop_metrics.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _py_interop_metrics.SwigPyIterator_equal(self, x)

    def copy(self):
        return _py_interop_metrics.SwigPyIterator_copy(self)

    def next(self):
        return _py_interop_metrics.SwigPyIterator_next(self)

    def __next__(self):
        return _py_interop_metrics.SwigPyIterator___next__(self)

    def previous(self):
        return _py_interop_metrics.SwigPyIterator_previous(self)

    def advance(self, n):
        return _py_interop_metrics.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _py_interop_metrics.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _py_interop_metrics.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _py_interop_metrics.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _py_interop_metrics.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _py_interop_metrics.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _py_interop_metrics.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _py_interop_metrics.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import interop.py_interop_run
class index_out_of_bounds_exception(interop.py_interop_run.base_exception):
    __swig_setmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_out_of_bounds_exception, name, value)
    __swig_getmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_out_of_bounds_exception, name)
    __repr__ = _swig_repr

    def __init__(self, mesg):
        this = _py_interop_metrics.new_index_out_of_bounds_exception(mesg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _py_interop_metrics.index_out_of_bounds_exception___str__(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_out_of_bounds_exception
    __del__ = lambda self: None
index_out_of_bounds_exception_swigregister = _py_interop_metrics.index_out_of_bounds_exception_swigregister
index_out_of_bounds_exception_swigregister(index_out_of_bounds_exception)

class csharp_date_time(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, csharp_date_time, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, csharp_date_time, name)
    __repr__ = _swig_repr

    def __init__(self, v=0):
        this = _py_interop_metrics.new_csharp_date_time(v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        to_unix = staticmethod(_py_interop_metrics.csharp_date_time_to_unix)
    else:
        to_unix = _py_interop_metrics.csharp_date_time_to_unix
    if _newclass:
        to_seconds = staticmethod(_py_interop_metrics.csharp_date_time_to_seconds)
    else:
        to_seconds = _py_interop_metrics.csharp_date_time_to_seconds
    if _newclass:
        to_csharp = staticmethod(_py_interop_metrics.csharp_date_time_to_csharp)
    else:
        to_csharp = _py_interop_metrics.csharp_date_time_to_csharp
    __swig_setmethods__["value"] = _py_interop_metrics.csharp_date_time_value_set
    __swig_getmethods__["value"] = _py_interop_metrics.csharp_date_time_value_get
    if _newclass:
        value = _swig_property(_py_interop_metrics.csharp_date_time_value_get, _py_interop_metrics.csharp_date_time_value_set)

    def to_int(self):
        return _py_interop_metrics.csharp_date_time_to_int(self)

    def to_binary(self):
        return _py_interop_metrics.csharp_date_time_to_binary(self)

    def __eq__(self, other):
        return _py_interop_metrics.csharp_date_time___eq__(self, other)
    __swig_destroy__ = _py_interop_metrics.delete_csharp_date_time
    __del__ = lambda self: None
csharp_date_time_swigregister = _py_interop_metrics.csharp_date_time_swigregister
csharp_date_time_swigregister(csharp_date_time)

def csharp_date_time_to_unix(*args):
    return _py_interop_metrics.csharp_date_time_to_unix(*args)
csharp_date_time_to_unix = _py_interop_metrics.csharp_date_time_to_unix

def csharp_date_time_to_seconds(*args):
    return _py_interop_metrics.csharp_date_time_to_seconds(*args)
csharp_date_time_to_seconds = _py_interop_metrics.csharp_date_time_to_seconds

def csharp_date_time_to_csharp(uval):
    return _py_interop_metrics.csharp_date_time_to_csharp(uval)
csharp_date_time_to_csharp = _py_interop_metrics.csharp_date_time_to_csharp

class empty_header(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, empty_header, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, empty_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_empty_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_empty_header
    __del__ = lambda self: None
empty_header_swigregister = _py_interop_metrics.empty_header_swigregister
empty_header_swigregister(empty_header)

class base_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_metric_header, name)
    __repr__ = _swig_repr
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_metric_header_default_header

    def __init__(self):
        this = _py_interop_metrics.new_base_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_base_metric_header
    __del__ = lambda self: None
base_metric_header_swigregister = _py_interop_metrics.base_metric_header_swigregister
base_metric_header_swigregister(base_metric_header)

def base_metric_header_default_header():
    return _py_interop_metrics.base_metric_header_default_header()
base_metric_header_default_header = _py_interop_metrics.base_metric_header_default_header

class empty_metric(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, empty_metric, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, empty_metric, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_empty_metric()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _py_interop_metrics.delete_empty_metric
    __del__ = lambda self: None
empty_metric_swigregister = _py_interop_metrics.empty_metric_swigregister
empty_metric_swigregister(empty_metric)

class base_metric(empty_metric):
    __swig_setmethods__ = {}
    for _s in [empty_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_metric, name)
    __repr__ = _swig_repr
    LANE_BIT_COUNT = _py_interop_metrics.base_metric_LANE_BIT_COUNT
    TILE_BIT_COUNT = _py_interop_metrics.base_metric_TILE_BIT_COUNT
    CYCLE_BIT_COUNT = _py_interop_metrics.base_metric_CYCLE_BIT_COUNT
    READ_BIT_COUNT = _py_interop_metrics.base_metric_READ_BIT_COUNT
    RESERVED_BIT_COUNT = _py_interop_metrics.base_metric_RESERVED_BIT_COUNT
    READ_BIT_SHIFT = _py_interop_metrics.base_metric_READ_BIT_SHIFT
    CYCLE_BIT_SHIFT = _py_interop_metrics.base_metric_CYCLE_BIT_SHIFT
    TILE_BIT_SHIFT = _py_interop_metrics.base_metric_TILE_BIT_SHIFT
    LANE_BIT_SHIFT = _py_interop_metrics.base_metric_LANE_BIT_SHIFT

    def __init__(self, lane=0, tile=0):
        this = _py_interop_metrics.new_base_metric(lane, tile)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, lane, tile):
        return _py_interop_metrics.base_metric_set_base(self, lane, tile)

    def id(self):
        return _py_interop_metrics.base_metric_id(self)

    def tile_hash(self):
        return _py_interop_metrics.base_metric_tile_hash(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_metric_create_id
    if _newclass:
        lane_from_id = staticmethod(_py_interop_metrics.base_metric_lane_from_id)
    else:
        lane_from_id = _py_interop_metrics.base_metric_lane_from_id
    if _newclass:
        tile_hash_from_id = staticmethod(_py_interop_metrics.base_metric_tile_hash_from_id)
    else:
        tile_hash_from_id = _py_interop_metrics.base_metric_tile_hash_from_id
    if _newclass:
        tile_from_id = staticmethod(_py_interop_metrics.base_metric_tile_from_id)
    else:
        tile_from_id = _py_interop_metrics.base_metric_tile_from_id

    def lane(self):
        return _py_interop_metrics.base_metric_lane(self)

    def tile(self):
        return _py_interop_metrics.base_metric_tile(self)

    def number(self, arg2):
        return _py_interop_metrics.base_metric_number(self, arg2)

    def section(self, method):
        return _py_interop_metrics.base_metric_section(self, method)

    def surface(self, method):
        return _py_interop_metrics.base_metric_surface(self, method)

    def swath(self, method):
        return _py_interop_metrics.base_metric_swath(self, method)

    def phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_phyiscalLocationIndex(self, method, section_per_lane, tile_count, swath_count, all_surfaces)

    def phyiscalLocationColumn(self, method, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_phyiscalLocationColumn(self, method, swath_count, all_surfaces)

    def phyiscalLocationRow(self, method, section_per_lane, tile_count):
        return _py_interop_metrics.base_metric_phyiscalLocationRow(self, method, section_per_lane, tile_count)

    def physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_physical_location_index(self, method, section_per_lane, tile_count, swath_count, all_surfaces)

    def physical_location_column(self, method, swath_count, all_surfaces):
        return _py_interop_metrics.base_metric_physical_location_column(self, method, swath_count, all_surfaces)

    def physical_location_row(self, method, section_per_lane, tile_count):
        return _py_interop_metrics.base_metric_physical_location_row(self, method, section_per_lane, tile_count)
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_metric_suffix)
    else:
        suffix = _py_interop_metrics.base_metric_suffix

    def __lt__(self, metric2):
        return _py_interop_metrics.base_metric___lt__(self, metric2)
    __swig_destroy__ = _py_interop_metrics.delete_base_metric
    __del__ = lambda self: None
base_metric_swigregister = _py_interop_metrics.base_metric_swigregister
base_metric_swigregister(base_metric)

def base_metric_create_id(lane, tile, arg3=0):
    return _py_interop_metrics.base_metric_create_id(lane, tile, arg3)
base_metric_create_id = _py_interop_metrics.base_metric_create_id

def base_metric_lane_from_id(id):
    return _py_interop_metrics.base_metric_lane_from_id(id)
base_metric_lane_from_id = _py_interop_metrics.base_metric_lane_from_id

def base_metric_tile_hash_from_id(id):
    return _py_interop_metrics.base_metric_tile_hash_from_id(id)
base_metric_tile_hash_from_id = _py_interop_metrics.base_metric_tile_hash_from_id

def base_metric_tile_from_id(id):
    return _py_interop_metrics.base_metric_tile_from_id(id)
base_metric_tile_from_id = _py_interop_metrics.base_metric_tile_from_id

def base_metric_suffix():
    return _py_interop_metrics.base_metric_suffix()
base_metric_suffix = _py_interop_metrics.base_metric_suffix

class base_cycle_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_cycle_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_cycle_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_cycle_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_cycle_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_cycle_metric_header_default_header

    def max_cycle(self):
        return _py_interop_metrics.base_cycle_metric_header_max_cycle(self)

    def clear(self):
        return _py_interop_metrics.base_cycle_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric_header
    __del__ = lambda self: None
base_cycle_metric_header_swigregister = _py_interop_metrics.base_cycle_metric_header_swigregister
base_cycle_metric_header_swigregister(base_cycle_metric_header)

def base_cycle_metric_header_default_header():
    return _py_interop_metrics.base_cycle_metric_header_default_header()
base_cycle_metric_header_default_header = _py_interop_metrics.base_cycle_metric_header_default_header

class base_cycle_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_cycle_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_cycle_metric, name)
    __repr__ = _swig_repr

    def __init__(self, lane=0, tile=0, cycle=0):
        this = _py_interop_metrics.new_base_cycle_metric(lane, tile, cycle)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, *args):
        return _py_interop_metrics.base_cycle_metric_set_base(self, *args)

    def cycle(self):
        return _py_interop_metrics.base_cycle_metric_cycle(self)

    def id(self):
        return _py_interop_metrics.base_cycle_metric_id(self)

    def cycle_hash(self):
        return _py_interop_metrics.base_cycle_metric_cycle_hash(self)
    if _newclass:
        cycle_from_id = staticmethod(_py_interop_metrics.base_cycle_metric_cycle_from_id)
    else:
        cycle_from_id = _py_interop_metrics.base_cycle_metric_cycle_from_id
    if _newclass:
        reserved_from_id = staticmethod(_py_interop_metrics.base_cycle_metric_reserved_from_id)
    else:
        reserved_from_id = _py_interop_metrics.base_cycle_metric_reserved_from_id
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_cycle_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_cycle_metric_create_id

    def __lt__(self, metric2):
        return _py_interop_metrics.base_cycle_metric___lt__(self, metric2)
    __swig_destroy__ = _py_interop_metrics.delete_base_cycle_metric
    __del__ = lambda self: None
base_cycle_metric_swigregister = _py_interop_metrics.base_cycle_metric_swigregister
base_cycle_metric_swigregister(base_cycle_metric)

def base_cycle_metric_cycle_from_id(id):
    return _py_interop_metrics.base_cycle_metric_cycle_from_id(id)
base_cycle_metric_cycle_from_id = _py_interop_metrics.base_cycle_metric_cycle_from_id

def base_cycle_metric_reserved_from_id(id):
    return _py_interop_metrics.base_cycle_metric_reserved_from_id(id)
base_cycle_metric_reserved_from_id = _py_interop_metrics.base_cycle_metric_reserved_from_id

def base_cycle_metric_create_id(lane, tile, cycle):
    return _py_interop_metrics.base_cycle_metric_create_id(lane, tile, cycle)
base_cycle_metric_create_id = _py_interop_metrics.base_cycle_metric_create_id

class base_read_metric_header(empty_header):
    __swig_setmethods__ = {}
    for _s in [empty_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_read_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [empty_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_read_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_base_read_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.base_read_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.base_read_metric_header_default_header
    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric_header
    __del__ = lambda self: None
base_read_metric_header_swigregister = _py_interop_metrics.base_read_metric_header_swigregister
base_read_metric_header_swigregister(base_read_metric_header)

def base_read_metric_header_default_header():
    return _py_interop_metrics.base_read_metric_header_default_header()
base_read_metric_header_default_header = _py_interop_metrics.base_read_metric_header_default_header

class base_read_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_read_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_read_metric, name)
    __repr__ = _swig_repr

    def __init__(self, lane, tile, read):
        this = _py_interop_metrics.new_base_read_metric(lane, tile, read)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set_base(self, *args):
        return _py_interop_metrics.base_read_metric_set_base(self, *args)

    def read(self):
        return _py_interop_metrics.base_read_metric_read(self)

    def id(self):
        return _py_interop_metrics.base_read_metric_id(self)
    if _newclass:
        create_id = staticmethod(_py_interop_metrics.base_read_metric_create_id)
    else:
        create_id = _py_interop_metrics.base_read_metric_create_id
    if _newclass:
        read_from_id = staticmethod(_py_interop_metrics.base_read_metric_read_from_id)
    else:
        read_from_id = _py_interop_metrics.base_read_metric_read_from_id

    def __lt__(self, metric2):
        return _py_interop_metrics.base_read_metric___lt__(self, metric2)
    __swig_destroy__ = _py_interop_metrics.delete_base_read_metric
    __del__ = lambda self: None
base_read_metric_swigregister = _py_interop_metrics.base_read_metric_swigregister
base_read_metric_swigregister(base_read_metric)

def base_read_metric_create_id(lane, tile, read):
    return _py_interop_metrics.base_read_metric_create_id(lane, tile, read)
base_read_metric_create_id = _py_interop_metrics.base_read_metric_create_id

def base_read_metric_read_from_id(id):
    return _py_interop_metrics.base_read_metric_read_from_id(id)
base_read_metric_read_from_id = _py_interop_metrics.base_read_metric_read_from_id

class point2d(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, point2d, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, point2d, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_point2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def x(self):
        return _py_interop_metrics.point2d_x(self)

    def y(self):
        return _py_interop_metrics.point2d_y(self)

    def size_in_bytes(self):
        return _py_interop_metrics.point2d_size_in_bytes(self)
    __swig_destroy__ = _py_interop_metrics.delete_point2d
    __del__ = lambda self: None
point2d_swigregister = _py_interop_metrics.point2d_swigregister
point2d_swigregister(point2d)

class index_info_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_info_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, index_info_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.index_info_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.index_info_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.index_info_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.index_info_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.index_info_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.index_info_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.index_info_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.index_info_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.index_info_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.index_info_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.index_info_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.index_info_vector_empty(self)

    def size(self):
        return _py_interop_metrics.index_info_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.index_info_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.index_info_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.index_info_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.index_info_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.index_info_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.index_info_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.index_info_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_info_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.index_info_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.index_info_vector_front(self)

    def back(self):
        return _py_interop_metrics.index_info_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.index_info_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.index_info_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.index_info_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.index_info_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.index_info_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_info_vector
    __del__ = lambda self: None
index_info_vector_swigregister = _py_interop_metrics.index_info_vector_swigregister
index_info_vector_swigregister(index_info_vector)

class tile_metric_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric_map, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.tile_metric_map___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.tile_metric_map___bool__(self)

    def __len__(self):
        return _py_interop_metrics.tile_metric_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _py_interop_metrics.tile_metric_map___getitem__(self, key)

    def __delitem__(self, key):
        return _py_interop_metrics.tile_metric_map___delitem__(self, key)

    def has_key(self, key):
        return _py_interop_metrics.tile_metric_map_has_key(self, key)

    def keys(self):
        return _py_interop_metrics.tile_metric_map_keys(self)

    def values(self):
        return _py_interop_metrics.tile_metric_map_values(self)

    def items(self):
        return _py_interop_metrics.tile_metric_map_items(self)

    def __contains__(self, key):
        return _py_interop_metrics.tile_metric_map___contains__(self, key)

    def key_iterator(self):
        return _py_interop_metrics.tile_metric_map_key_iterator(self)

    def value_iterator(self):
        return _py_interop_metrics.tile_metric_map_value_iterator(self)

    def __setitem__(self, *args):
        return _py_interop_metrics.tile_metric_map___setitem__(self, *args)

    def asdict(self):
        return _py_interop_metrics.tile_metric_map_asdict(self)

    def __init__(self, *args):
        this = _py_interop_metrics.new_tile_metric_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _py_interop_metrics.tile_metric_map_empty(self)

    def size(self):
        return _py_interop_metrics.tile_metric_map_size(self)

    def swap(self, v):
        return _py_interop_metrics.tile_metric_map_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.tile_metric_map_rbegin(self)

    def rend(self):
        return _py_interop_metrics.tile_metric_map_rend(self)

    def clear(self):
        return _py_interop_metrics.tile_metric_map_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.tile_metric_map_get_allocator(self)

    def count(self, x):
        return _py_interop_metrics.tile_metric_map_count(self, x)

    def erase(self, *args):
        return _py_interop_metrics.tile_metric_map_erase(self, *args)

    def find(self, x):
        return _py_interop_metrics.tile_metric_map_find(self, x)

    def lower_bound(self, x):
        return _py_interop_metrics.tile_metric_map_lower_bound(self, x)

    def upper_bound(self, x):
        return _py_interop_metrics.tile_metric_map_upper_bound(self, x)
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_map
    __del__ = lambda self: None
tile_metric_map_swigregister = _py_interop_metrics.tile_metric_map_swigregister
tile_metric_map_swigregister(tile_metric_map)

class cycle_metric_map(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, cycle_metric_map, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, cycle_metric_map, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.cycle_metric_map___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.cycle_metric_map___bool__(self)

    def __len__(self):
        return _py_interop_metrics.cycle_metric_map___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _py_interop_metrics.cycle_metric_map___getitem__(self, key)

    def __delitem__(self, key):
        return _py_interop_metrics.cycle_metric_map___delitem__(self, key)

    def has_key(self, key):
        return _py_interop_metrics.cycle_metric_map_has_key(self, key)

    def keys(self):
        return _py_interop_metrics.cycle_metric_map_keys(self)

    def values(self):
        return _py_interop_metrics.cycle_metric_map_values(self)

    def items(self):
        return _py_interop_metrics.cycle_metric_map_items(self)

    def __contains__(self, key):
        return _py_interop_metrics.cycle_metric_map___contains__(self, key)

    def key_iterator(self):
        return _py_interop_metrics.cycle_metric_map_key_iterator(self)

    def value_iterator(self):
        return _py_interop_metrics.cycle_metric_map_value_iterator(self)

    def __setitem__(self, *args):
        return _py_interop_metrics.cycle_metric_map___setitem__(self, *args)

    def asdict(self):
        return _py_interop_metrics.cycle_metric_map_asdict(self)

    def __init__(self, *args):
        this = _py_interop_metrics.new_cycle_metric_map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        return _py_interop_metrics.cycle_metric_map_empty(self)

    def size(self):
        return _py_interop_metrics.cycle_metric_map_size(self)

    def swap(self, v):
        return _py_interop_metrics.cycle_metric_map_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.cycle_metric_map_rbegin(self)

    def rend(self):
        return _py_interop_metrics.cycle_metric_map_rend(self)

    def clear(self):
        return _py_interop_metrics.cycle_metric_map_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.cycle_metric_map_get_allocator(self)

    def count(self, x):
        return _py_interop_metrics.cycle_metric_map_count(self, x)

    def erase(self, *args):
        return _py_interop_metrics.cycle_metric_map_erase(self, *args)

    def find(self, x):
        return _py_interop_metrics.cycle_metric_map_find(self, x)

    def lower_bound(self, x):
        return _py_interop_metrics.cycle_metric_map_lower_bound(self, x)

    def upper_bound(self, x):
        return _py_interop_metrics.cycle_metric_map_upper_bound(self, x)
    __swig_destroy__ = _py_interop_metrics.delete_cycle_metric_map
    __del__ = lambda self: None
cycle_metric_map_swigregister = _py_interop_metrics.cycle_metric_map_swigregister
cycle_metric_map_swigregister(cycle_metric_map)

class read_metric_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, read_metric_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, read_metric_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.read_metric_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.read_metric_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.read_metric_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.read_metric_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.read_metric_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.read_metric_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.read_metric_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.read_metric_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.read_metric_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.read_metric_vector_empty(self)

    def size(self):
        return _py_interop_metrics.read_metric_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.read_metric_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.read_metric_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.read_metric_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.read_metric_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.read_metric_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.read_metric_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.read_metric_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_read_metric_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.read_metric_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.read_metric_vector_front(self)

    def back(self):
        return _py_interop_metrics.read_metric_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.read_metric_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.read_metric_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.read_metric_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.read_metric_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.read_metric_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_read_metric_vector
    __del__ = lambda self: None
read_metric_vector_swigregister = _py_interop_metrics.read_metric_vector_swigregister
read_metric_vector_swigregister(read_metric_vector)

class q_score_bin_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_bin_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_bin_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.q_score_bin_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.q_score_bin_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.q_score_bin_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.q_score_bin_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.q_score_bin_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.q_score_bin_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.q_score_bin_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.q_score_bin_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.q_score_bin_vector_empty(self)

    def size(self):
        return _py_interop_metrics.q_score_bin_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.q_score_bin_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.q_score_bin_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.q_score_bin_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.q_score_bin_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.q_score_bin_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.q_score_bin_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.q_score_bin_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_score_bin_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.q_score_bin_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.q_score_bin_vector_front(self)

    def back(self):
        return _py_interop_metrics.q_score_bin_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.q_score_bin_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.q_score_bin_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.q_score_bin_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.q_score_bin_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.q_score_bin_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin_vector
    __del__ = lambda self: None
q_score_bin_vector_swigregister = _py_interop_metrics.q_score_bin_vector_swigregister
q_score_bin_vector_swigregister(q_score_bin_vector)

class metric_type_name_pair(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_name_pair, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_name_pair, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_name_pair(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _py_interop_metrics.metric_type_name_pair_first_set
    __swig_getmethods__["first"] = _py_interop_metrics.metric_type_name_pair_first_get
    if _newclass:
        first = _swig_property(_py_interop_metrics.metric_type_name_pair_first_get, _py_interop_metrics.metric_type_name_pair_first_set)
    __swig_setmethods__["second"] = _py_interop_metrics.metric_type_name_pair_second_set
    __swig_getmethods__["second"] = _py_interop_metrics.metric_type_name_pair_second_get
    if _newclass:
        second = _swig_property(_py_interop_metrics.metric_type_name_pair_second_get, _py_interop_metrics.metric_type_name_pair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_name_pair
    __del__ = lambda self: None
metric_type_name_pair_swigregister = _py_interop_metrics.metric_type_name_pair_swigregister
metric_type_name_pair_swigregister(metric_type_name_pair)

class metric_type_description(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_description, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_description, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_description(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def value(self):
        return _py_interop_metrics.metric_type_description_value(self)

    def description(self):
        return _py_interop_metrics.metric_type_description_description(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description
    __del__ = lambda self: None
metric_type_description_swigregister = _py_interop_metrics.metric_type_description_swigregister
metric_type_description_swigregister(metric_type_description)

class metric_type_description_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_description_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_description_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_type_description_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_type_description_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_type_description_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_type_description_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_type_description_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_type_description_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_type_description_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_type_description_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_type_description_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_type_description_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_type_description_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_type_description_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_type_description_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_type_description_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_type_description_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_type_description_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_type_description_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_description_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_type_description_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_type_description_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_type_description_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_type_description_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_type_description_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_type_description_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_type_description_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_type_description_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_description_vector
    __del__ = lambda self: None
metric_type_description_vector_swigregister = _py_interop_metrics.metric_type_description_vector_swigregister
metric_type_description_vector_swigregister(metric_type_description_vector)

class metric_type_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_type_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_type_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_type_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_type_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_type_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_type_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_type_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_type_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_type_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_type_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_type_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_type_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_type_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_type_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_type_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_type_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_type_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_type_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_type_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_type_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_type_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_type_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_type_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_type_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_type_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_type_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_type_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_type_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_type_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_type_vector
    __del__ = lambda self: None
metric_type_vector_swigregister = _py_interop_metrics.metric_type_vector_swigregister
metric_type_vector_swigregister(metric_type_vector)

class metric_group_vector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, metric_group_vector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, metric_group_vector, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.metric_group_vector___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.metric_group_vector___bool__(self)

    def __len__(self):
        return _py_interop_metrics.metric_group_vector___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.metric_group_vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.metric_group_vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.metric_group_vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.metric_group_vector___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.metric_group_vector_pop(self)

    def append(self, x):
        return _py_interop_metrics.metric_group_vector_append(self, x)

    def empty(self):
        return _py_interop_metrics.metric_group_vector_empty(self)

    def size(self):
        return _py_interop_metrics.metric_group_vector_size(self)

    def swap(self, v):
        return _py_interop_metrics.metric_group_vector_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.metric_group_vector_rbegin(self)

    def rend(self):
        return _py_interop_metrics.metric_group_vector_rend(self)

    def clear(self):
        return _py_interop_metrics.metric_group_vector_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.metric_group_vector_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.metric_group_vector_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.metric_group_vector_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_metric_group_vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.metric_group_vector_push_back(self, x)

    def front(self):
        return _py_interop_metrics.metric_group_vector_front(self)

    def back(self):
        return _py_interop_metrics.metric_group_vector_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.metric_group_vector_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.metric_group_vector_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.metric_group_vector_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.metric_group_vector_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.metric_group_vector_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_metric_group_vector
    __del__ = lambda self: None
metric_group_vector_swigregister = _py_interop_metrics.metric_group_vector_swigregister
metric_group_vector_swigregister(metric_group_vector)

class corrected_intensity_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, corrected_intensity_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, corrected_intensity_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.corrected_intensity_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.corrected_intensity_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_corrected_intensity_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lane, tile, cycle, called_counts):
        return _py_interop_metrics.corrected_intensity_metric_set(self, lane, tile, cycle, called_counts)

    def average_cycle_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_average_cycle_intensity(self)

    def corrected_int_all(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all(self, index)

    def corrected_int_all_float(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_float(self, index)

    def corrected_int_called(self, index):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called(self, index)

    def called_counts_array(self):
        return _py_interop_metrics.corrected_intensity_metric_called_counts_array(self)

    def corrected_int_all_array(self):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_all_array(self)

    def called_counts(self, index):
        return _py_interop_metrics.corrected_intensity_metric_called_counts(self, index)

    def no_calls(self):
        return _py_interop_metrics.corrected_intensity_metric_no_calls(self)

    def signal_to_noise(self):
        return _py_interop_metrics.corrected_intensity_metric_signal_to_noise(self)

    def total_calls(self, nocalls=False):
        return _py_interop_metrics.corrected_intensity_metric_total_calls(self, nocalls)

    def total_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_total_intensity(self)

    def total_called_intensity(self):
        return _py_interop_metrics.corrected_intensity_metric_total_called_intensity(self)

    def percent_base(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percent_base(self, index)

    def percent_bases(self):
        return _py_interop_metrics.corrected_intensity_metric_percent_bases(self)

    def percent_nocall(self):
        return _py_interop_metrics.corrected_intensity_metric_percent_nocall(self)

    def corrected_int_called_array(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_corrected_int_called_array(self, *args)

    def any_valid_called_int(self):
        return _py_interop_metrics.corrected_intensity_metric_any_valid_called_int(self)

    def averageCycleIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_averageCycleIntensity(self)

    def correctedIntCalled(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_correctedIntCalled(self, *args)

    def correctedIntAll(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_correctedIntAll(self, *args)

    def noCalls(self):
        return _py_interop_metrics.corrected_intensity_metric_noCalls(self)

    def percentBase(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentBase(self, index)

    def calledCounts(self, *args):
        return _py_interop_metrics.corrected_intensity_metric_calledCounts(self, *args)

    def signalToNoise(self):
        return _py_interop_metrics.corrected_intensity_metric_signalToNoise(self)

    def totalCalls(self, nocalls=False):
        return _py_interop_metrics.corrected_intensity_metric_totalCalls(self, nocalls)

    def totalIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_totalIntensity(self)

    def totalCalledIntensity(self):
        return _py_interop_metrics.corrected_intensity_metric_totalCalledIntensity(self)

    def percentIntensity(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentIntensity(self, index)

    def percentCalledIntensity(self, index):
        return _py_interop_metrics.corrected_intensity_metric_percentCalledIntensity(self, index)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.corrected_intensity_metric_prefix)
    else:
        prefix = _py_interop_metrics.corrected_intensity_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_corrected_intensity_metric
    __del__ = lambda self: None
corrected_intensity_metric_swigregister = _py_interop_metrics.corrected_intensity_metric_swigregister
corrected_intensity_metric_swigregister(corrected_intensity_metric)

def corrected_intensity_metric_prefix():
    return _py_interop_metrics.corrected_intensity_metric_prefix()
corrected_intensity_metric_prefix = _py_interop_metrics.corrected_intensity_metric_prefix

class error_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, error_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, error_metric, name)
    __repr__ = _swig_repr
    MAX_MISMATCH = _py_interop_metrics.error_metric_MAX_MISMATCH
    TYPE = _py_interop_metrics.error_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.error_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_error_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def error_rate(self):
        return _py_interop_metrics.error_metric_error_rate(self)

    def mismatch_cluster_count(self, n):
        return _py_interop_metrics.error_metric_mismatch_cluster_count(self, n)

    def mismatch_count(self):
        return _py_interop_metrics.error_metric_mismatch_count(self)

    def mismatch_cluster_counts(self):
        return _py_interop_metrics.error_metric_mismatch_cluster_counts(self)

    def errorRate(self):
        return _py_interop_metrics.error_metric_errorRate(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.error_metric_prefix)
    else:
        prefix = _py_interop_metrics.error_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_error_metric
    __del__ = lambda self: None
error_metric_swigregister = _py_interop_metrics.error_metric_swigregister
error_metric_swigregister(error_metric)

def error_metric_prefix():
    return _py_interop_metrics.error_metric_prefix()
error_metric_prefix = _py_interop_metrics.error_metric_prefix

class extended_tile_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extended_tile_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extended_tile_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.extended_tile_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.extended_tile_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_extended_tile_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.extended_tile_metric_set(self, *args)

    def cluster_count_occupied(self):
        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied(self)

    def cluster_count_occupied_k(self):
        return _py_interop_metrics.extended_tile_metric_cluster_count_occupied_k(self)

    def percent_occupied(self):
        return _py_interop_metrics.extended_tile_metric_percent_occupied(self)

    def upper_left(self):
        return _py_interop_metrics.extended_tile_metric_upper_left(self)

    def set_cluster_count_k(self, cluster_count_k):
        return _py_interop_metrics.extended_tile_metric_set_cluster_count_k(self, cluster_count_k)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.extended_tile_metric_prefix)
    else:
        prefix = _py_interop_metrics.extended_tile_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_extended_tile_metric
    __del__ = lambda self: None
extended_tile_metric_swigregister = _py_interop_metrics.extended_tile_metric_swigregister
extended_tile_metric_swigregister(extended_tile_metric)

def extended_tile_metric_prefix():
    return _py_interop_metrics.extended_tile_metric_prefix()
extended_tile_metric_prefix = _py_interop_metrics.extended_tile_metric_prefix

class extraction_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extraction_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extraction_metric_header, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.extraction_metric_header_MAX_CHANNELS

    def __init__(self, channel_count):
        this = _py_interop_metrics.new_extraction_metric_header(channel_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channel_count(self, *args):
        return _py_interop_metrics.extraction_metric_header_channel_count(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.extraction_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.extraction_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.extraction_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric_header
    __del__ = lambda self: None
extraction_metric_header_swigregister = _py_interop_metrics.extraction_metric_header_swigregister
extraction_metric_header_swigregister(extraction_metric_header)

def extraction_metric_header_default_header():
    return _py_interop_metrics.extraction_metric_header_default_header()
extraction_metric_header_default_header = _py_interop_metrics.extraction_metric_header_default_header

class extraction_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, extraction_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, extraction_metric, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.extraction_metric_MAX_CHANNELS
    TYPE = _py_interop_metrics.extraction_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.extraction_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_extraction_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, *args):
        return _py_interop_metrics.extraction_metric_set(self, *args)

    def date_time_csharp(self):
        return _py_interop_metrics.extraction_metric_date_time_csharp(self)

    def date_time_csharp_raw(self):
        return _py_interop_metrics.extraction_metric_date_time_csharp_raw(self)

    def max_intensity(self, channel):
        return _py_interop_metrics.extraction_metric_max_intensity(self, channel)

    def focus_score(self, channel):
        return _py_interop_metrics.extraction_metric_focus_score(self, channel)

    def max_intensity_values(self):
        return _py_interop_metrics.extraction_metric_max_intensity_values(self)

    def focus_scores(self):
        return _py_interop_metrics.extraction_metric_focus_scores(self)

    def channel_count(self):
        return _py_interop_metrics.extraction_metric_channel_count(self)

    def trim(self, channel_count):
        return _py_interop_metrics.extraction_metric_trim(self, channel_count)

    def focusScore(self, channel):
        return _py_interop_metrics.extraction_metric_focusScore(self, channel)

    def dateTime(self):
        return _py_interop_metrics.extraction_metric_dateTime(self)

    def focusScores(self):
        return _py_interop_metrics.extraction_metric_focusScores(self)

    def date_time(self, *args):
        return _py_interop_metrics.extraction_metric_date_time(self, *args)

    def is_any_p90_zero(self):
        return _py_interop_metrics.extraction_metric_is_any_p90_zero(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.extraction_metric_prefix)
    else:
        prefix = _py_interop_metrics.extraction_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_extraction_metric
    __del__ = lambda self: None
extraction_metric_swigregister = _py_interop_metrics.extraction_metric_swigregister
extraction_metric_swigregister(extraction_metric)

def extraction_metric_prefix():
    return _py_interop_metrics.extraction_metric_prefix()
extraction_metric_prefix = _py_interop_metrics.extraction_metric_prefix

class image_metric_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, image_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, image_metric_header, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.image_metric_header_MAX_CHANNELS

    def __init__(self, channel_count):
        this = _py_interop_metrics.new_image_metric_header(channel_count)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def channelCount(self):
        return _py_interop_metrics.image_metric_header_channelCount(self)

    def channel_count(self, *args):
        return _py_interop_metrics.image_metric_header_channel_count(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.image_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.image_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.image_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_image_metric_header
    __del__ = lambda self: None
image_metric_header_swigregister = _py_interop_metrics.image_metric_header_swigregister
image_metric_header_swigregister(image_metric_header)

def image_metric_header_default_header():
    return _py_interop_metrics.image_metric_header_default_header()
image_metric_header_default_header = _py_interop_metrics.image_metric_header_default_header

class image_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, image_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, image_metric, name)
    __repr__ = _swig_repr
    MAX_CHANNELS = _py_interop_metrics.image_metric_MAX_CHANNELS
    TYPE = _py_interop_metrics.image_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.image_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_image_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def min_contrast(self, channel):
        return _py_interop_metrics.image_metric_min_contrast(self, channel)

    def max_contrast(self, channel):
        return _py_interop_metrics.image_metric_max_contrast(self, channel)

    def min_contrast_array(self):
        return _py_interop_metrics.image_metric_min_contrast_array(self)

    def max_contrast_array(self):
        return _py_interop_metrics.image_metric_max_contrast_array(self)

    def channel_count(self):
        return _py_interop_metrics.image_metric_channel_count(self)

    def is_any_channel_blank(self):
        return _py_interop_metrics.image_metric_is_any_channel_blank(self)

    def trim(self, channel_count):
        return _py_interop_metrics.image_metric_trim(self, channel_count)

    def minContrast(self, *args):
        return _py_interop_metrics.image_metric_minContrast(self, *args)

    def maxContrast(self, *args):
        return _py_interop_metrics.image_metric_maxContrast(self, *args)

    def channelCount(self):
        return _py_interop_metrics.image_metric_channelCount(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.image_metric_prefix)
    else:
        prefix = _py_interop_metrics.image_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_image_metric
    __del__ = lambda self: None
image_metric_swigregister = _py_interop_metrics.image_metric_swigregister
image_metric_swigregister(image_metric)

def image_metric_prefix():
    return _py_interop_metrics.image_metric_prefix()
image_metric_prefix = _py_interop_metrics.image_metric_prefix

class q_score_bin(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_bin, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_bin, name)
    __repr__ = _swig_repr

    def __init__(self, lower=0, upper=0, value=0):
        this = _py_interop_metrics.new_q_score_bin(lower, upper, value)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def lower(self):
        return _py_interop_metrics.q_score_bin_lower(self)

    def upper(self):
        return _py_interop_metrics.q_score_bin_upper(self)

    def value(self):
        return _py_interop_metrics.q_score_bin_value(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_bin
    __del__ = lambda self: None
q_score_bin_swigregister = _py_interop_metrics.q_score_bin_swigregister
q_score_bin_swigregister(q_score_bin)

class q_score_header(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_score_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_score_header, name)
    __repr__ = _swig_repr
    MAX_Q_BINS = _py_interop_metrics.q_score_header_MAX_Q_BINS

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_score_header(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def bin_at(self, n):
        return _py_interop_metrics.q_score_header_bin_at(self, n)

    def get_bins(self):
        return _py_interop_metrics.q_score_header_get_bins(self)

    def bins(self):
        return _py_interop_metrics.q_score_header_bins(self)

    def bin_count(self):
        return _py_interop_metrics.q_score_header_bin_count(self)

    def q_val_count(self):
        return _py_interop_metrics.q_score_header_q_val_count(self)

    def index_for_q_value(self, qval):
        return _py_interop_metrics.q_score_header_index_for_q_value(self, qval)

    def binCount(self):
        return _py_interop_metrics.q_score_header_binCount(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.q_score_header_default_header)
    else:
        default_header = _py_interop_metrics.q_score_header_default_header

    def binAt(self, n):
        return _py_interop_metrics.q_score_header_binAt(self, n)

    def clear(self):
        return _py_interop_metrics.q_score_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_score_header
    __del__ = lambda self: None
q_score_header_swigregister = _py_interop_metrics.q_score_header_swigregister
q_score_header_swigregister(q_score_header)

def q_score_header_default_header():
    return _py_interop_metrics.q_score_header_default_header()
q_score_header_default_header = _py_interop_metrics.q_score_header_default_header

class q_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_metric_LATEST_VERSION
    MAX_Q_BINS = _py_interop_metrics.q_metric_MAX_Q_BINS

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def set(self, lane, tile, cycle, qscore_hist):
        return _py_interop_metrics.q_metric_set(self, lane, tile, cycle, qscore_hist)

    def qscore_hist(self, *args):
        return _py_interop_metrics.q_metric_qscore_hist(self, *args)

    def size(self):
        return _py_interop_metrics.q_metric_size(self)

    def sum_qscore(self):
        return _py_interop_metrics.q_metric_sum_qscore(self)

    def sum_qscore_cumulative(self):
        return _py_interop_metrics.q_metric_sum_qscore_cumulative(self)

    def total_over_qscore(self, *args):
        return _py_interop_metrics.q_metric_total_over_qscore(self, *args)

    def total_over_qscore_cumulative(self, *args):
        return _py_interop_metrics.q_metric_total_over_qscore_cumulative(self, *args)

    def percent_over_qscore(self, *args):
        return _py_interop_metrics.q_metric_percent_over_qscore(self, *args)

    def percent_over_qscore_cumulative(self, *args):
        return _py_interop_metrics.q_metric_percent_over_qscore_cumulative(self, *args)

    def median(self, *args):
        return _py_interop_metrics.q_metric_median(self, *args)

    def is_cumulative_empty(self):
        return _py_interop_metrics.q_metric_is_cumulative_empty(self)

    def accumulate(self, metric):
        return _py_interop_metrics.q_metric_accumulate(self, metric)

    def compress(self, header):
        return _py_interop_metrics.q_metric_compress(self, header)

    def qscoreHist(self, *args):
        return _py_interop_metrics.q_metric_qscoreHist(self, *args)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.q_metric_prefix)
    else:
        prefix = _py_interop_metrics.q_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_q_metric
    __del__ = lambda self: None
q_metric_swigregister = _py_interop_metrics.q_metric_swigregister
q_metric_swigregister(q_metric)

def q_metric_prefix():
    return _py_interop_metrics.q_metric_prefix()
q_metric_prefix = _py_interop_metrics.q_metric_prefix

class tile_metric_header(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self, density):
        this = _py_interop_metrics.new_tile_metric_header(density)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def density(self):
        return _py_interop_metrics.tile_metric_header_density(self)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.tile_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.tile_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.tile_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric_header
    __del__ = lambda self: None
tile_metric_header_swigregister = _py_interop_metrics.tile_metric_header_swigregister
tile_metric_header_swigregister(tile_metric_header)

def tile_metric_header_default_header():
    return _py_interop_metrics.tile_metric_header_default_header()
tile_metric_header_default_header = _py_interop_metrics.tile_metric_header_default_header

class read_metric(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, read_metric, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, read_metric, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_read_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def read(self):
        return _py_interop_metrics.read_metric_read(self)

    def percent_aligned(self, *args):
        return _py_interop_metrics.read_metric_percent_aligned(self, *args)

    def percent_phasing(self, *args):
        return _py_interop_metrics.read_metric_percent_phasing(self, *args)

    def percent_prephasing(self, *args):
        return _py_interop_metrics.read_metric_percent_prephasing(self, *args)
    __swig_destroy__ = _py_interop_metrics.delete_read_metric
    __del__ = lambda self: None
read_metric_swigregister = _py_interop_metrics.read_metric_swigregister
read_metric_swigregister(read_metric)

class tile_metric(base_metric):
    __swig_setmethods__ = {}
    for _s in [base_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, tile_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, tile_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.tile_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.tile_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_tile_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def cluster_density(self):
        return _py_interop_metrics.tile_metric_cluster_density(self)

    def cluster_density_k(self):
        return _py_interop_metrics.tile_metric_cluster_density_k(self)

    def cluster_density_pf(self):
        return _py_interop_metrics.tile_metric_cluster_density_pf(self)

    def cluster_density_pf_k(self):
        return _py_interop_metrics.tile_metric_cluster_density_pf_k(self)

    def cluster_count(self):
        return _py_interop_metrics.tile_metric_cluster_count(self)

    def cluster_count_k(self):
        return _py_interop_metrics.tile_metric_cluster_count_k(self)

    def cluster_count_m(self):
        return _py_interop_metrics.tile_metric_cluster_count_m(self)

    def cluster_count_pf(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf(self)

    def cluster_count_pf_k(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf_k(self)

    def cluster_count_pf_m(self):
        return _py_interop_metrics.tile_metric_cluster_count_pf_m(self)

    def percent_pf(self):
        return _py_interop_metrics.tile_metric_percent_pf(self)

    def read_metrics(self):
        return _py_interop_metrics.tile_metric_read_metrics(self)

    def percent_aligned(self, n):
        return _py_interop_metrics.tile_metric_percent_aligned(self, n)

    def percent_phasing(self, n):
        return _py_interop_metrics.tile_metric_percent_phasing(self, n)

    def percent_prephasing(self, n):
        return _py_interop_metrics.tile_metric_percent_prephasing(self, n)

    def percent_aligned_at(self, number):
        return _py_interop_metrics.tile_metric_percent_aligned_at(self, number)

    def percent_phasing_at(self, number):
        return _py_interop_metrics.tile_metric_percent_phasing_at(self, number)

    def percent_prephasing_at(self, number):
        return _py_interop_metrics.tile_metric_percent_prephasing_at(self, number)

    def read_count(self):
        return _py_interop_metrics.tile_metric_read_count(self)

    def is_dead_tile(self):
        return _py_interop_metrics.tile_metric_is_dead_tile(self)

    def update_phasing_if_missing(self, number, phasing, prephasing):
        return _py_interop_metrics.tile_metric_update_phasing_if_missing(self, number, phasing, prephasing)

    def clusterDensity(self):
        return _py_interop_metrics.tile_metric_clusterDensity(self)

    def clusterDensityPf(self):
        return _py_interop_metrics.tile_metric_clusterDensityPf(self)

    def clusterCount(self):
        return _py_interop_metrics.tile_metric_clusterCount(self)

    def clusterCountPf(self):
        return _py_interop_metrics.tile_metric_clusterCountPf(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.tile_metric_prefix)
    else:
        prefix = _py_interop_metrics.tile_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_tile_metric
    __del__ = lambda self: None
tile_metric_swigregister = _py_interop_metrics.tile_metric_swigregister
tile_metric_swigregister(tile_metric)

def tile_metric_prefix():
    return _py_interop_metrics.tile_metric_prefix()
tile_metric_prefix = _py_interop_metrics.tile_metric_prefix

class index_info(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_info, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, index_info, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_info(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def index_seq(self):
        return _py_interop_metrics.index_info_index_seq(self)

    def sample_id(self):
        return _py_interop_metrics.index_info_sample_id(self)

    def sample_proj(self):
        return _py_interop_metrics.index_info_sample_proj(self)

    def cluster_count(self):
        return _py_interop_metrics.index_info_cluster_count(self)

    def is_dual(self):
        return _py_interop_metrics.index_info_is_dual(self)

    def index1(self):
        return _py_interop_metrics.index_info_index1(self)

    def index2(self):
        return _py_interop_metrics.index_info_index2(self)

    def unique_id(self):
        return _py_interop_metrics.index_info_unique_id(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_info
    __del__ = lambda self: None
index_info_swigregister = _py_interop_metrics.index_info_swigregister
index_info_swigregister(index_info)

class index_metric_header(base_read_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_metric_header, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_metric_header, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _py_interop_metrics.new_index_metric_header()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def index_order(self, *args):
        return _py_interop_metrics.index_metric_header_index_order(self, *args)
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.index_metric_header_default_header)
    else:
        default_header = _py_interop_metrics.index_metric_header_default_header

    def clear(self):
        return _py_interop_metrics.index_metric_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_index_metric_header
    __del__ = lambda self: None
index_metric_header_swigregister = _py_interop_metrics.index_metric_header_swigregister
index_metric_header_swigregister(index_metric_header)

def index_metric_header_default_header():
    return _py_interop_metrics.index_metric_header_default_header()
index_metric_header_default_header = _py_interop_metrics.index_metric_header_default_header

class index_metric(base_read_metric):
    __swig_setmethods__ = {}
    for _s in [base_read_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, index_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_read_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, index_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.index_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.index_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_index_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def size(self):
        return _py_interop_metrics.index_metric_size(self)

    def indices(self, *args):
        return _py_interop_metrics.index_metric_indices(self, *args)

    def cluster_count(self):
        return _py_interop_metrics.index_metric_cluster_count(self)

    def cluster_count_pf(self):
        return _py_interop_metrics.index_metric_cluster_count_pf(self)

    def set_cluster_counts(self, cluster_count, cluster_count_pf):
        return _py_interop_metrics.index_metric_set_cluster_counts(self, cluster_count, cluster_count_pf)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.index_metric_prefix)
    else:
        prefix = _py_interop_metrics.index_metric_prefix
    __swig_destroy__ = _py_interop_metrics.delete_index_metric
    __del__ = lambda self: None
index_metric_swigregister = _py_interop_metrics.index_metric_swigregister
index_metric_swigregister(index_metric)

def index_metric_prefix():
    return _py_interop_metrics.index_metric_prefix()
index_metric_prefix = _py_interop_metrics.index_metric_prefix

class q_collapsed_header(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_collapsed_header, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_collapsed_header, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_collapsed_header(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        default_header = staticmethod(_py_interop_metrics.q_collapsed_header_default_header)
    else:
        default_header = _py_interop_metrics.q_collapsed_header_default_header

    def clear(self):
        return _py_interop_metrics.q_collapsed_header_clear(self)
    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_header
    __del__ = lambda self: None
q_collapsed_header_swigregister = _py_interop_metrics.q_collapsed_header_swigregister
q_collapsed_header_swigregister(q_collapsed_header)

def q_collapsed_header_default_header():
    return _py_interop_metrics.q_collapsed_header_default_header()
q_collapsed_header_default_header = _py_interop_metrics.q_collapsed_header_default_header

class q_collapsed_metric(base_cycle_metric):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_collapsed_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_collapsed_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_collapsed_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_collapsed_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_collapsed_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def q20(self):
        return _py_interop_metrics.q_collapsed_metric_q20(self)

    def q30(self):
        return _py_interop_metrics.q_collapsed_metric_q30(self)

    def total(self):
        return _py_interop_metrics.q_collapsed_metric_total(self)

    def median_qscore(self):
        return _py_interop_metrics.q_collapsed_metric_median_qscore(self)

    def median_qscore_flt(self):
        return _py_interop_metrics.q_collapsed_metric_median_qscore_flt(self)

    def cumulative_q20(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_q20(self)

    def cumulative_q30(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_q30(self)

    def cumulative_total(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_total(self)

    def percent_over_q20(self):
        return _py_interop_metrics.q_collapsed_metric_percent_over_q20(self)

    def percent_over_q30(self):
        return _py_interop_metrics.q_collapsed_metric_percent_over_q30(self)

    def cumulative_percent_over_q20(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q20(self)

    def cumulative_percent_over_q30(self):
        return _py_interop_metrics.q_collapsed_metric_cumulative_percent_over_q30(self)

    def accumulate(self, metric):
        return _py_interop_metrics.q_collapsed_metric_accumulate(self, metric)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.q_collapsed_metric_prefix)
    else:
        prefix = _py_interop_metrics.q_collapsed_metric_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.q_collapsed_metric_suffix)
    else:
        suffix = _py_interop_metrics.q_collapsed_metric_suffix
    __swig_destroy__ = _py_interop_metrics.delete_q_collapsed_metric
    __del__ = lambda self: None
q_collapsed_metric_swigregister = _py_interop_metrics.q_collapsed_metric_swigregister
q_collapsed_metric_swigregister(q_collapsed_metric)

def q_collapsed_metric_prefix():
    return _py_interop_metrics.q_collapsed_metric_prefix()
q_collapsed_metric_prefix = _py_interop_metrics.q_collapsed_metric_prefix

def q_collapsed_metric_suffix():
    return _py_interop_metrics.q_collapsed_metric_suffix()
q_collapsed_metric_suffix = _py_interop_metrics.q_collapsed_metric_suffix

class q_by_lane_metric(q_metric):
    __swig_setmethods__ = {}
    for _s in [q_metric]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, q_by_lane_metric, name, value)
    __swig_getmethods__ = {}
    for _s in [q_metric]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, q_by_lane_metric, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.q_by_lane_metric_TYPE
    LATEST_VERSION = _py_interop_metrics.q_by_lane_metric_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_q_by_lane_metric(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def accumulate_by_lane(self, metric):
        return _py_interop_metrics.q_by_lane_metric_accumulate_by_lane(self, metric)
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.q_by_lane_metric_suffix)
    else:
        suffix = _py_interop_metrics.q_by_lane_metric_suffix
    __swig_destroy__ = _py_interop_metrics.delete_q_by_lane_metric
    __del__ = lambda self: None
q_by_lane_metric_swigregister = _py_interop_metrics.q_by_lane_metric_swigregister
q_by_lane_metric_swigregister(q_by_lane_metric)

def q_by_lane_metric_suffix():
    return _py_interop_metrics.q_by_lane_metric_suffix()
q_by_lane_metric_suffix = _py_interop_metrics.q_by_lane_metric_suffix

class base_corrected_intensity_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_corrected_intensity_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_corrected_intensity_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_corrected_intensity_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_corrected_intensity_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_corrected_intensity_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_corrected_intensity_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_corrected_intensity_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_corrected_intensity_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_corrected_intensity_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_corrected_intensity_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_corrected_intensity_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_corrected_intensity_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_corrected_intensity_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_corrected_intensity_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_corrected_intensity_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_corrected_intensity_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_corrected_intensity_metrics
    __del__ = lambda self: None
base_corrected_intensity_metrics_swigregister = _py_interop_metrics.base_corrected_intensity_metrics_swigregister
base_corrected_intensity_metrics_swigregister(base_corrected_intensity_metrics)

def base_corrected_intensity_metrics_prefix():
    return _py_interop_metrics.base_corrected_intensity_metrics_prefix()
base_corrected_intensity_metrics_prefix = _py_interop_metrics.base_corrected_intensity_metrics_prefix

def base_corrected_intensity_metrics_suffix():
    return _py_interop_metrics.base_corrected_intensity_metrics_suffix()
base_corrected_intensity_metrics_suffix = _py_interop_metrics.base_corrected_intensity_metrics_suffix

class vector_corrected_intensity_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_corrected_intensity_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_corrected_intensity_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_corrected_intensity_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_corrected_intensity_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_corrected_intensity_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_corrected_intensity_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_corrected_intensity_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_corrected_intensity_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_corrected_intensity_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_corrected_intensity_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_corrected_intensity_metrics
    __del__ = lambda self: None
vector_corrected_intensity_metrics_swigregister = _py_interop_metrics.vector_corrected_intensity_metrics_swigregister
vector_corrected_intensity_metrics_swigregister(vector_corrected_intensity_metrics)

class base_error_metrics(base_cycle_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_error_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_cycle_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_error_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_error_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_error_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_error_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_error_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_error_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_error_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_error_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_error_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_error_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_error_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_error_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_error_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_error_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_error_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_error_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_error_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_error_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_error_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_error_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_error_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_error_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_error_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_error_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_error_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_error_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_error_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_error_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_error_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_error_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_error_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_error_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_error_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_error_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_error_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_error_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_error_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_error_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_error_metrics
    __del__ = lambda self: None
base_error_metrics_swigregister = _py_interop_metrics.base_error_metrics_swigregister
base_error_metrics_swigregister(base_error_metrics)

def base_error_metrics_prefix():
    return _py_interop_metrics.base_error_metrics_prefix()
base_error_metrics_prefix = _py_interop_metrics.base_error_metrics_prefix

def base_error_metrics_suffix():
    return _py_interop_metrics.base_error_metrics_suffix()
base_error_metrics_suffix = _py_interop_metrics.base_error_metrics_suffix

class vector_error_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_error_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_error_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_error_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_error_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_error_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_error_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_error_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_error_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_error_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_error_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_error_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_error_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_error_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_error_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_error_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_error_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_error_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_error_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_error_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_error_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_error_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_error_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_error_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_error_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_error_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_error_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_error_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_error_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_error_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_error_metrics
    __del__ = lambda self: None
vector_error_metrics_swigregister = _py_interop_metrics.vector_error_metrics_swigregister
vector_error_metrics_swigregister(vector_error_metrics)

class base_extended_tile_metrics(base_metric_header):
    __swig_setmethods__ = {}
    for _s in [base_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_extended_tile_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [base_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_extended_tile_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_extended_tile_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_extended_tile_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_extended_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_extended_tile_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_extended_tile_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_extended_tile_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_extended_tile_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_extended_tile_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_extended_tile_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_extended_tile_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_extended_tile_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_extended_tile_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_extended_tile_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_extended_tile_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_extended_tile_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_extended_tile_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_extended_tile_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_extended_tile_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_extended_tile_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_extended_tile_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_extended_tile_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_extended_tile_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_extended_tile_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_extended_tile_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_extended_tile_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_extended_tile_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_extended_tile_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_extended_tile_metrics
    __del__ = lambda self: None
base_extended_tile_metrics_swigregister = _py_interop_metrics.base_extended_tile_metrics_swigregister
base_extended_tile_metrics_swigregister(base_extended_tile_metrics)

def base_extended_tile_metrics_prefix():
    return _py_interop_metrics.base_extended_tile_metrics_prefix()
base_extended_tile_metrics_prefix = _py_interop_metrics.base_extended_tile_metrics_prefix

def base_extended_tile_metrics_suffix():
    return _py_interop_metrics.base_extended_tile_metrics_suffix()
base_extended_tile_metrics_suffix = _py_interop_metrics.base_extended_tile_metrics_suffix

class vector_extended_tile_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_extended_tile_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_extended_tile_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_extended_tile_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_extended_tile_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_extended_tile_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_extended_tile_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_extended_tile_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_extended_tile_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_extended_tile_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_extended_tile_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_extended_tile_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_extended_tile_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_extended_tile_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_extended_tile_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_extended_tile_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_extended_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_extended_tile_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_extended_tile_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_extended_tile_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_extended_tile_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_extended_tile_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_extended_tile_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_extended_tile_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_extended_tile_metrics
    __del__ = lambda self: None
vector_extended_tile_metrics_swigregister = _py_interop_metrics.vector_extended_tile_metrics_swigregister
vector_extended_tile_metrics_swigregister(vector_extended_tile_metrics)

class base_extraction_metrics(extraction_metric_header):
    __swig_setmethods__ = {}
    for _s in [extraction_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_extraction_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [extraction_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_extraction_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_extraction_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_extraction_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_extraction_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_extraction_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_extraction_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_extraction_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_extraction_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_extraction_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_extraction_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_extraction_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_extraction_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_extraction_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_extraction_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_extraction_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_extraction_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_extraction_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_extraction_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_extraction_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_extraction_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_extraction_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_extraction_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_extraction_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_extraction_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_extraction_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_extraction_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_extraction_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_extraction_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_extraction_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_extraction_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_extraction_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_extraction_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_extraction_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_extraction_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_extraction_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_extraction_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_extraction_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_extraction_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_extraction_metrics
    __del__ = lambda self: None
base_extraction_metrics_swigregister = _py_interop_metrics.base_extraction_metrics_swigregister
base_extraction_metrics_swigregister(base_extraction_metrics)

def base_extraction_metrics_prefix():
    return _py_interop_metrics.base_extraction_metrics_prefix()
base_extraction_metrics_prefix = _py_interop_metrics.base_extraction_metrics_prefix

def base_extraction_metrics_suffix():
    return _py_interop_metrics.base_extraction_metrics_suffix()
base_extraction_metrics_suffix = _py_interop_metrics.base_extraction_metrics_suffix

class vector_extraction_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_extraction_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_extraction_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_extraction_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_extraction_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_extraction_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_extraction_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_extraction_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_extraction_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_extraction_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_extraction_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_extraction_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_extraction_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_extraction_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_extraction_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_extraction_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_extraction_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_extraction_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_extraction_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_extraction_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_extraction_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_extraction_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_extraction_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_extraction_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_extraction_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_extraction_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_extraction_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_extraction_metrics
    __del__ = lambda self: None
vector_extraction_metrics_swigregister = _py_interop_metrics.vector_extraction_metrics_swigregister
vector_extraction_metrics_swigregister(vector_extraction_metrics)

class base_image_metrics(image_metric_header):
    __swig_setmethods__ = {}
    for _s in [image_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_image_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [image_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_image_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_image_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_image_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_image_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_image_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_image_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_image_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_image_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_image_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_image_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_image_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_image_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_image_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_image_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_image_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_image_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_image_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_image_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_image_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_image_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_image_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_image_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_image_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_image_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_image_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_image_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_image_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_image_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_image_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_image_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_image_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_image_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_image_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_image_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_image_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_image_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_image_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_image_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_image_metrics
    __del__ = lambda self: None
base_image_metrics_swigregister = _py_interop_metrics.base_image_metrics_swigregister
base_image_metrics_swigregister(base_image_metrics)

def base_image_metrics_prefix():
    return _py_interop_metrics.base_image_metrics_prefix()
base_image_metrics_prefix = _py_interop_metrics.base_image_metrics_prefix

def base_image_metrics_suffix():
    return _py_interop_metrics.base_image_metrics_suffix()
base_image_metrics_suffix = _py_interop_metrics.base_image_metrics_suffix

class vector_image_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_image_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_image_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_image_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_image_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_image_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_image_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_image_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_image_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_image_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_image_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_image_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_image_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_image_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_image_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_image_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_image_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_image_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_image_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_image_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_image_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_image_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_image_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_image_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_image_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_image_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_image_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_image_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_image_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_image_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_image_metrics
    __del__ = lambda self: None
vector_image_metrics_swigregister = _py_interop_metrics.vector_image_metrics_swigregister
vector_image_metrics_swigregister(vector_image_metrics)

class base_q_metrics(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_q_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_q_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_q_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_q_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_q_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_q_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_metrics
    __del__ = lambda self: None
base_q_metrics_swigregister = _py_interop_metrics.base_q_metrics_swigregister
base_q_metrics_swigregister(base_q_metrics)

def base_q_metrics_prefix():
    return _py_interop_metrics.base_q_metrics_prefix()
base_q_metrics_prefix = _py_interop_metrics.base_q_metrics_prefix

def base_q_metrics_suffix():
    return _py_interop_metrics.base_q_metrics_suffix()
base_q_metrics_suffix = _py_interop_metrics.base_q_metrics_suffix

class vector_q_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_metrics
    __del__ = lambda self: None
vector_q_metrics_swigregister = _py_interop_metrics.vector_q_metrics_swigregister
vector_q_metrics_swigregister(vector_q_metrics)

class base_tile_metrics(tile_metric_header):
    __swig_setmethods__ = {}
    for _s in [tile_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_tile_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [tile_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_tile_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_tile_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_tile_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_tile_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_tile_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_tile_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_tile_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_tile_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_tile_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_tile_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_tile_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_tile_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_tile_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_tile_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_tile_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_tile_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_tile_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_tile_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_tile_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_tile_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_tile_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_tile_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_tile_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_tile_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_tile_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_tile_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_tile_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_tile_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_tile_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_tile_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_tile_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_tile_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_tile_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_tile_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_tile_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_tile_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_tile_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_tile_metrics
    __del__ = lambda self: None
base_tile_metrics_swigregister = _py_interop_metrics.base_tile_metrics_swigregister
base_tile_metrics_swigregister(base_tile_metrics)

def base_tile_metrics_prefix():
    return _py_interop_metrics.base_tile_metrics_prefix()
base_tile_metrics_prefix = _py_interop_metrics.base_tile_metrics_prefix

def base_tile_metrics_suffix():
    return _py_interop_metrics.base_tile_metrics_suffix()
base_tile_metrics_suffix = _py_interop_metrics.base_tile_metrics_suffix

class vector_tile_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_tile_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_tile_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_tile_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_tile_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_tile_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_tile_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_tile_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_tile_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_tile_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_tile_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_tile_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_tile_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_tile_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_tile_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_tile_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_tile_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_tile_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_tile_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_tile_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_tile_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_tile_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_tile_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_tile_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_tile_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_tile_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_tile_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_tile_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_tile_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_tile_metrics
    __del__ = lambda self: None
vector_tile_metrics_swigregister = _py_interop_metrics.vector_tile_metrics_swigregister
vector_tile_metrics_swigregister(vector_tile_metrics)

class base_index_metrics(index_metric_header):
    __swig_setmethods__ = {}
    for _s in [index_metric_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_index_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [index_metric_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_index_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_index_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_index_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_index_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_index_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_index_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_index_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_index_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_index_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_index_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_index_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_index_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_index_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_index_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_index_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_index_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_index_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_index_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_index_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_index_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_index_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_index_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_index_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_index_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_index_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_index_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_index_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_index_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_index_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_index_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_index_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_index_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_index_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_index_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_index_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_index_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_index_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_index_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_index_metrics
    __del__ = lambda self: None
base_index_metrics_swigregister = _py_interop_metrics.base_index_metrics_swigregister
base_index_metrics_swigregister(base_index_metrics)

def base_index_metrics_prefix():
    return _py_interop_metrics.base_index_metrics_prefix()
base_index_metrics_prefix = _py_interop_metrics.base_index_metrics_prefix

def base_index_metrics_suffix():
    return _py_interop_metrics.base_index_metrics_suffix()
base_index_metrics_suffix = _py_interop_metrics.base_index_metrics_suffix

class vector_index_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_index_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_index_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_index_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_index_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_index_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_index_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_index_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_index_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_index_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_index_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_index_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_index_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_index_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_index_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_index_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_index_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_index_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_index_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_index_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_index_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_index_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_index_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_index_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_index_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_index_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_index_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_index_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_index_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_index_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_index_metrics
    __del__ = lambda self: None
vector_index_metrics_swigregister = _py_interop_metrics.vector_index_metrics_swigregister
vector_index_metrics_swigregister(vector_index_metrics)

class base_q_collapsed_metrics(q_collapsed_header):
    __swig_setmethods__ = {}
    for _s in [q_collapsed_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_collapsed_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_collapsed_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_collapsed_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_collapsed_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_collapsed_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_collapsed_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_q_collapsed_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_q_collapsed_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_q_collapsed_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_collapsed_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_collapsed_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_collapsed_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_collapsed_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_collapsed_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_collapsed_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_collapsed_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_collapsed_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_collapsed_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_collapsed_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_collapsed_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_collapsed_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_collapsed_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_collapsed_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_collapsed_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_collapsed_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_collapsed_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_collapsed_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_collapsed_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_q_collapsed_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_collapsed_metrics
    __del__ = lambda self: None
base_q_collapsed_metrics_swigregister = _py_interop_metrics.base_q_collapsed_metrics_swigregister
base_q_collapsed_metrics_swigregister(base_q_collapsed_metrics)

def base_q_collapsed_metrics_prefix():
    return _py_interop_metrics.base_q_collapsed_metrics_prefix()
base_q_collapsed_metrics_prefix = _py_interop_metrics.base_q_collapsed_metrics_prefix

def base_q_collapsed_metrics_suffix():
    return _py_interop_metrics.base_q_collapsed_metrics_suffix()
base_q_collapsed_metrics_suffix = _py_interop_metrics.base_q_collapsed_metrics_suffix

class vector_q_collapsed_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_collapsed_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_collapsed_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_collapsed_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_collapsed_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_collapsed_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_collapsed_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_collapsed_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_collapsed_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_collapsed_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_collapsed_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_collapsed_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_collapsed_metrics
    __del__ = lambda self: None
vector_q_collapsed_metrics_swigregister = _py_interop_metrics.vector_q_collapsed_metrics_swigregister
vector_q_collapsed_metrics_swigregister(vector_q_collapsed_metrics)

class base_q_by_lane_metrics(q_score_header):
    __swig_setmethods__ = {}
    for _s in [q_score_header]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, base_q_by_lane_metrics, name, value)
    __swig_getmethods__ = {}
    for _s in [q_score_header]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, base_q_by_lane_metrics, name)
    __repr__ = _swig_repr
    TYPE = _py_interop_metrics.base_q_by_lane_metrics_TYPE
    LATEST_VERSION = _py_interop_metrics.base_q_by_lane_metrics_LATEST_VERSION

    def __init__(self, *args):
        this = _py_interop_metrics.new_base_q_by_lane_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def copy_by_tile(self, origin, tile_id):
        return _py_interop_metrics.base_q_by_lane_metrics_copy_by_tile(self, origin, tile_id)

    def append_tiles(self, origin, tile_id):
        return _py_interop_metrics.base_q_by_lane_metrics_append_tiles(self, origin, tile_id)

    def data_source_exists(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_data_source_exists(self, *args)

    def sort(self):
        return _py_interop_metrics.base_q_by_lane_metrics_sort(self)

    def rebuild_index(self, update_ids=False):
        return _py_interop_metrics.base_q_by_lane_metrics_rebuild_index(self, update_ids)

    def resize(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_resize(self, n)

    def reserve(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_reserve(self, n)

    def trim(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_trim(self, n)

    def insert(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_insert(self, *args)

    def at(self, n):
        return _py_interop_metrics.base_q_by_lane_metrics_at(self, n)

    def set_version(self, version):
        return _py_interop_metrics.base_q_by_lane_metrics_set_version(self, version)

    def keys(self):
        return _py_interop_metrics.base_q_by_lane_metrics_keys(self)

    def lanes(self):
        return _py_interop_metrics.base_q_by_lane_metrics_lanes(self)

    def lane_count(self):
        return _py_interop_metrics.base_q_by_lane_metrics_lane_count(self)

    def max_lane(self):
        return _py_interop_metrics.base_q_by_lane_metrics_max_lane(self)

    def tile_numbers_for_lane(self, lane):
        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers_for_lane(self, lane)

    def tile_numbers(self):
        return _py_interop_metrics.base_q_by_lane_metrics_tile_numbers(self)

    def metrics_for_lane(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_lane(self, *args)

    def cycles(self):
        return _py_interop_metrics.base_q_by_lane_metrics_cycles(self)

    def metrics_for_cycle(self, cycle):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics_for_cycle(self, cycle)

    def size(self):
        return _py_interop_metrics.base_q_by_lane_metrics_size(self)

    def empty(self):
        return _py_interop_metrics.base_q_by_lane_metrics_empty(self)

    def version(self):
        return _py_interop_metrics.base_q_by_lane_metrics_version(self)

    def clear(self):
        return _py_interop_metrics.base_q_by_lane_metrics_clear(self)

    def metrics(self):
        return _py_interop_metrics.base_q_by_lane_metrics_metrics(self)
    if _newclass:
        prefix = staticmethod(_py_interop_metrics.base_q_by_lane_metrics_prefix)
    else:
        prefix = _py_interop_metrics.base_q_by_lane_metrics_prefix
    if _newclass:
        suffix = staticmethod(_py_interop_metrics.base_q_by_lane_metrics_suffix)
    else:
        suffix = _py_interop_metrics.base_q_by_lane_metrics_suffix

    def get_metric_ref(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_get_metric_ref(self, *args)

    def find(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_find(self, *args)

    def get_metric(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_get_metric(self, *args)

    def has_metric(self, *args):
        return _py_interop_metrics.base_q_by_lane_metrics_has_metric(self, *args)

    def clear_lookup(self):
        return _py_interop_metrics.base_q_by_lane_metrics_clear_lookup(self)
    __swig_destroy__ = _py_interop_metrics.delete_base_q_by_lane_metrics
    __del__ = lambda self: None
base_q_by_lane_metrics_swigregister = _py_interop_metrics.base_q_by_lane_metrics_swigregister
base_q_by_lane_metrics_swigregister(base_q_by_lane_metrics)

def base_q_by_lane_metrics_prefix():
    return _py_interop_metrics.base_q_by_lane_metrics_prefix()
base_q_by_lane_metrics_prefix = _py_interop_metrics.base_q_by_lane_metrics_prefix

def base_q_by_lane_metrics_suffix():
    return _py_interop_metrics.base_q_by_lane_metrics_suffix()
base_q_by_lane_metrics_suffix = _py_interop_metrics.base_q_by_lane_metrics_suffix

class vector_q_by_lane_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vector_q_by_lane_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vector_q_by_lane_metrics, name)
    __repr__ = _swig_repr
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___nonzero__(self)

    def __bool__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___bool__(self)

    def __len__(self):
        return _py_interop_metrics.vector_q_by_lane_metrics___len__(self)

    def __getslice__(self, i, j):
        return _py_interop_metrics.vector_q_by_lane_metrics___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _py_interop_metrics.vector_q_by_lane_metrics___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___delitem__(self, *args)

    def __getitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___getitem__(self, *args)

    def __setitem__(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics___setitem__(self, *args)

    def pop(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_pop(self)

    def append(self, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_append(self, x)

    def empty(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_empty(self)

    def size(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_size(self)

    def swap(self, v):
        return _py_interop_metrics.vector_q_by_lane_metrics_swap(self, v)

    def rbegin(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_rbegin(self)

    def rend(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_rend(self)

    def clear(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_clear(self)

    def get_allocator(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_get_allocator(self)

    def pop_back(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_pop_back(self)

    def erase(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_erase(self, *args)

    def __init__(self, *args):
        this = _py_interop_metrics.new_vector_q_by_lane_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_push_back(self, x)

    def front(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_front(self)

    def back(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_back(self)

    def assign(self, n, x):
        return _py_interop_metrics.vector_q_by_lane_metrics_assign(self, n, x)

    def resize(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_resize(self, *args)

    def insert(self, *args):
        return _py_interop_metrics.vector_q_by_lane_metrics_insert(self, *args)

    def reserve(self, n):
        return _py_interop_metrics.vector_q_by_lane_metrics_reserve(self, n)

    def capacity(self):
        return _py_interop_metrics.vector_q_by_lane_metrics_capacity(self)
    __swig_destroy__ = _py_interop_metrics.delete_vector_q_by_lane_metrics
    __del__ = lambda self: None
vector_q_by_lane_metrics_swigregister = _py_interop_metrics.vector_q_by_lane_metrics_swigregister
vector_q_by_lane_metrics_swigregister(vector_q_by_lane_metrics)

# This file is compatible with both classic and new-style classes.


