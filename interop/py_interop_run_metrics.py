# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_py_interop_run_metrics')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_py_interop_run_metrics')
    _py_interop_run_metrics = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_py_interop_run_metrics', [dirname(__file__)])
        except ImportError:
            import _py_interop_run_metrics
            return _py_interop_run_metrics
        try:
            _mod = imp.load_module('_py_interop_run_metrics', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _py_interop_run_metrics = swig_import_helper()
    del swig_import_helper
else:
    import _py_interop_run_metrics
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _py_interop_run_metrics.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _py_interop_run_metrics.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _py_interop_run_metrics.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _py_interop_run_metrics.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _py_interop_run_metrics.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _py_interop_run_metrics.SwigPyIterator_equal(self, x)

    def copy(self):
        return _py_interop_run_metrics.SwigPyIterator_copy(self)

    def next(self):
        return _py_interop_run_metrics.SwigPyIterator_next(self)

    def __next__(self):
        return _py_interop_run_metrics.SwigPyIterator___next__(self)

    def previous(self):
        return _py_interop_run_metrics.SwigPyIterator_previous(self)

    def advance(self, n):
        return _py_interop_run_metrics.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _py_interop_run_metrics.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _py_interop_run_metrics.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _py_interop_run_metrics.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _py_interop_run_metrics.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _py_interop_run_metrics.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _py_interop_run_metrics.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _py_interop_run_metrics.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import interop.py_interop_run
import interop.py_interop_comm
import interop.py_interop_metrics
class invalid_channel_exception(interop.py_interop_run.base_exception):
    __swig_setmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, invalid_channel_exception, name, value)
    __swig_getmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, invalid_channel_exception, name)
    __repr__ = _swig_repr

    def __init__(self, mesg):
        this = _py_interop_run_metrics.new_invalid_channel_exception(mesg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _py_interop_run_metrics.invalid_channel_exception___str__(self)
    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_channel_exception
    __del__ = lambda self: None
invalid_channel_exception_swigregister = _py_interop_run_metrics.invalid_channel_exception_swigregister
invalid_channel_exception_swigregister(invalid_channel_exception)

class invalid_metric_type(interop.py_interop_run.base_exception):
    __swig_setmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, invalid_metric_type, name, value)
    __swig_getmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, invalid_metric_type, name)
    __repr__ = _swig_repr

    def __init__(self, mesg):
        this = _py_interop_run_metrics.new_invalid_metric_type(mesg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _py_interop_run_metrics.invalid_metric_type___str__(self)
    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_metric_type
    __del__ = lambda self: None
invalid_metric_type_swigregister = _py_interop_run_metrics.invalid_metric_type_swigregister
invalid_metric_type_swigregister(invalid_metric_type)

class invalid_parameter(interop.py_interop_run.base_exception):
    __swig_setmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, invalid_parameter, name, value)
    __swig_getmethods__ = {}
    for _s in [interop.py_interop_run.base_exception]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, invalid_parameter, name)
    __repr__ = _swig_repr

    def __init__(self, mesg):
        this = _py_interop_run_metrics.new_invalid_parameter(mesg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self):
        return _py_interop_run_metrics.invalid_parameter___str__(self)
    __swig_destroy__ = _py_interop_run_metrics.delete_invalid_parameter
    __del__ = lambda self: None
invalid_parameter_swigregister = _py_interop_run_metrics.invalid_parameter_swigregister
invalid_parameter_swigregister(invalid_parameter)


def copy_focus(metrics, focus_scores, channel, n):
    return _py_interop_run_metrics.copy_focus(metrics, focus_scores, channel, n)
copy_focus = _py_interop_run_metrics.copy_focus

def count_q_metric_bins(*args):
    return _py_interop_run_metrics.count_q_metric_bins(*args)
count_q_metric_bins = _py_interop_run_metrics.count_q_metric_bins

def populate_cumulative_distribution(*args):
    return _py_interop_run_metrics.populate_cumulative_distribution(*args)
populate_cumulative_distribution = _py_interop_run_metrics.populate_cumulative_distribution

def requires_legacy_bins(count):
    return _py_interop_run_metrics.requires_legacy_bins(count)
requires_legacy_bins = _py_interop_run_metrics.requires_legacy_bins

def compress_q_metrics(*args):
    return _py_interop_run_metrics.compress_q_metrics(*args)
compress_q_metrics = _py_interop_run_metrics.compress_q_metrics

def populate_legacy_q_score_bins(*args):
    return _py_interop_run_metrics.populate_legacy_q_score_bins(*args)
populate_legacy_q_score_bins = _py_interop_run_metrics.populate_legacy_q_score_bins

def count_qvals(*args):
    return _py_interop_run_metrics.count_qvals(*args)
count_qvals = _py_interop_run_metrics.count_qvals

def is_compressed(*args):
    return _py_interop_run_metrics.is_compressed(*args)
is_compressed = _py_interop_run_metrics.is_compressed

def max_qval(*args):
    return _py_interop_run_metrics.max_qval(*args)
max_qval = _py_interop_run_metrics.max_qval

def index_for_q_value(*args):
    return _py_interop_run_metrics.index_for_q_value(*args)
index_for_q_value = _py_interop_run_metrics.index_for_q_value

def create_collapse_q_metrics(metric_set, collapsed):
    return _py_interop_run_metrics.create_collapse_q_metrics(metric_set, collapsed)
create_collapse_q_metrics = _py_interop_run_metrics.create_collapse_q_metrics

def create_q_metrics_by_lane(metric_set, bylane, instrument):
    return _py_interop_run_metrics.create_q_metrics_by_lane(metric_set, bylane, instrument)
create_q_metrics_by_lane = _py_interop_run_metrics.create_q_metrics_by_lane

def to_group(type):
    return _py_interop_run_metrics.to_group(type)
to_group = _py_interop_run_metrics.to_group

def to_description(type):
    return _py_interop_run_metrics.to_description(type)
to_description = _py_interop_run_metrics.to_description

def list_descriptions(types):
    return _py_interop_run_metrics.list_descriptions(types)
list_descriptions = _py_interop_run_metrics.list_descriptions

def to_feature(type):
    return _py_interop_run_metrics.to_feature(type)
to_feature = _py_interop_run_metrics.to_feature

def to_group_feature(type):
    return _py_interop_run_metrics.to_group_feature(type)
to_group_feature = _py_interop_run_metrics.to_group_feature

def is_base_metric(type):
    return _py_interop_run_metrics.is_base_metric(type)
is_base_metric = _py_interop_run_metrics.is_base_metric

def is_channel_metric(type):
    return _py_interop_run_metrics.is_channel_metric(type)
is_channel_metric = _py_interop_run_metrics.is_channel_metric

def is_read_metric(type):
    return _py_interop_run_metrics.is_read_metric(type)
is_read_metric = _py_interop_run_metrics.is_read_metric

def is_cycle_metric(type):
    return _py_interop_run_metrics.is_cycle_metric(type)
is_cycle_metric = _py_interop_run_metrics.is_cycle_metric

def is_tile_metric(type):
    return _py_interop_run_metrics.is_tile_metric(type)
is_tile_metric = _py_interop_run_metrics.is_tile_metric

def list_metrics_to_load_metric_group(*args):
    return _py_interop_run_metrics.list_metrics_to_load_metric_group(*args)
list_metrics_to_load_metric_group = _py_interop_run_metrics.list_metrics_to_load_metric_group

def list_metrics_to_load_by_group(*args):
    return _py_interop_run_metrics.list_metrics_to_load_by_group(*args)
list_metrics_to_load_by_group = _py_interop_run_metrics.list_metrics_to_load_by_group

def list_metrics_to_load_by_type(*args):
    return _py_interop_run_metrics.list_metrics_to_load_by_type(*args)
list_metrics_to_load_by_type = _py_interop_run_metrics.list_metrics_to_load_by_type

def list_metrics_to_load_metric_groups(*args):
    return _py_interop_run_metrics.list_metrics_to_load_metric_groups(*args)
list_metrics_to_load_metric_groups = _py_interop_run_metrics.list_metrics_to_load_metric_groups

def list_metrics_to_load_by_groups(*args):
    return _py_interop_run_metrics.list_metrics_to_load_by_groups(*args)
list_metrics_to_load_by_groups = _py_interop_run_metrics.list_metrics_to_load_by_groups

def list_metrics_to_load_by_types(*args):
    return _py_interop_run_metrics.list_metrics_to_load_by_types(*args)
list_metrics_to_load_by_types = _py_interop_run_metrics.list_metrics_to_load_by_types

def list_metrics_to_load(*args):
    return _py_interop_run_metrics.list_metrics_to_load(*args)
list_metrics_to_load = _py_interop_run_metrics.list_metrics_to_load

def list_summary_metric_groups(*args):
    return _py_interop_run_metrics.list_summary_metric_groups(*args)
list_summary_metric_groups = _py_interop_run_metrics.list_summary_metric_groups

def list_index_summary_metric_groups(groups):
    return _py_interop_run_metrics.list_index_summary_metric_groups(groups)
list_index_summary_metric_groups = _py_interop_run_metrics.list_index_summary_metric_groups

def list_summary_metrics_to_load(*args):
    return _py_interop_run_metrics.list_summary_metrics_to_load(*args)
list_summary_metrics_to_load = _py_interop_run_metrics.list_summary_metrics_to_load

def list_index_metrics_to_load(valid_to_load):
    return _py_interop_run_metrics.list_index_metrics_to_load(valid_to_load)
list_index_metrics_to_load = _py_interop_run_metrics.list_index_metrics_to_load

def list_analysis_metrics_to_load(valid_to_load):
    return _py_interop_run_metrics.list_analysis_metrics_to_load(valid_to_load)
list_analysis_metrics_to_load = _py_interop_run_metrics.list_analysis_metrics_to_load
class run_metrics(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, run_metrics, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, run_metrics, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _py_interop_run_metrics.new_run_metrics(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def read(self, *args):
        return _py_interop_run_metrics.run_metrics_read(self, *args)

    def read_xml(self, run_folder):
        return _py_interop_run_metrics.run_metrics_read_xml(self, run_folder)

    def read_run_info(self, run_folder):
        return _py_interop_run_metrics.run_metrics_read_run_info(self, run_folder)

    def read_run_parameters(self, run_folder, force_load=False):
        return _py_interop_run_metrics.run_metrics_read_run_parameters(self, run_folder, force_load)

    def finalize_after_load(self, *args):
        return _py_interop_run_metrics.run_metrics_finalize_after_load(self, *args)

    def empty(self):
        return _py_interop_run_metrics.run_metrics_empty(self)

    def legacy_channel_update(self, type):
        return _py_interop_run_metrics.run_metrics_legacy_channel_update(self, type)

    def set_naming_method(self, naming_method):
        return _py_interop_run_metrics.run_metrics_set_naming_method(self, naming_method)

    def count_legacy_bins(self, *args):
        return _py_interop_run_metrics.run_metrics_count_legacy_bins(self, *args)

    def is_run_parameters_required(self, *args):
        return _py_interop_run_metrics.run_metrics_is_run_parameters_required(self, *args)

    def run_info(self, *args):
        return _py_interop_run_metrics.run_metrics_run_info(self, *args)

    def run_parameters(self, *args):
        return _py_interop_run_metrics.run_metrics_run_parameters(self, *args)

    def list_filenames(self, *args):
        return _py_interop_run_metrics.run_metrics_list_filenames(self, *args)

    def copy_tile(self, metrics, tile_id):
        return _py_interop_run_metrics.run_metrics_copy_tile(self, metrics, tile_id)

    def append_tiles(self, metrics, tile_id):
        return _py_interop_run_metrics.run_metrics_append_tiles(self, metrics, tile_id)

    def check_for_data_sources(self, run_folder, last_cycle):
        return _py_interop_run_metrics.run_metrics_check_for_data_sources(self, run_folder, last_cycle)

    def read_metrics(self, *args):
        return _py_interop_run_metrics.run_metrics_read_metrics(self, *args)

    def write_metrics(self, run_folder, use_out=True):
        return _py_interop_run_metrics.run_metrics_write_metrics(self, run_folder, use_out)

    def read_metrics_from_buffer(self, group, buffer, buffer_size):
        return _py_interop_run_metrics.run_metrics_read_metrics_from_buffer(self, group, buffer, buffer_size)

    def write_metrics_to_buffer(self, group, buffer, buffer_size):
        return _py_interop_run_metrics.run_metrics_write_metrics_to_buffer(self, group, buffer, buffer_size)

    def calculate_buffer_size(self, group):
        return _py_interop_run_metrics.run_metrics_calculate_buffer_size(self, group)

    def validate(self):
        return _py_interop_run_metrics.run_metrics_validate(self)

    def is_group_empty(self, *args):
        return _py_interop_run_metrics.run_metrics_is_group_empty(self, *args)

    def populate_id_map(self, *args):
        return _py_interop_run_metrics.run_metrics_populate_id_map(self, *args)

    def sort(self):
        return _py_interop_run_metrics.run_metrics_sort(self)

    def clear(self):
        return _py_interop_run_metrics.run_metrics_clear(self)

    def set_corrected_intensity_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_corrected_intensity_metric_set(self, metrics)

    def corrected_intensity_metric_set(self):
        return _py_interop_run_metrics.run_metrics_corrected_intensity_metric_set(self)

    def set_error_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_error_metric_set(self, metrics)

    def error_metric_set(self):
        return _py_interop_run_metrics.run_metrics_error_metric_set(self)

    def set_extended_tile_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_extended_tile_metric_set(self, metrics)

    def extended_tile_metric_set(self):
        return _py_interop_run_metrics.run_metrics_extended_tile_metric_set(self)

    def set_extraction_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_extraction_metric_set(self, metrics)

    def extraction_metric_set(self):
        return _py_interop_run_metrics.run_metrics_extraction_metric_set(self)

    def set_image_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_image_metric_set(self, metrics)

    def image_metric_set(self):
        return _py_interop_run_metrics.run_metrics_image_metric_set(self)

    def set_q_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_q_metric_set(self, metrics)

    def q_metric_set(self):
        return _py_interop_run_metrics.run_metrics_q_metric_set(self)

    def set_tile_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_tile_metric_set(self, metrics)

    def tile_metric_set(self):
        return _py_interop_run_metrics.run_metrics_tile_metric_set(self)

    def set_index_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_index_metric_set(self, metrics)

    def index_metric_set(self):
        return _py_interop_run_metrics.run_metrics_index_metric_set(self)

    def set_q_collapsed_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_q_collapsed_metric_set(self, metrics)

    def q_collapsed_metric_set(self):
        return _py_interop_run_metrics.run_metrics_q_collapsed_metric_set(self)

    def set_q_by_lane_metric_set(self, metrics):
        return _py_interop_run_metrics.run_metrics_set_q_by_lane_metric_set(self, metrics)

    def q_by_lane_metric_set(self):
        return _py_interop_run_metrics.run_metrics_q_by_lane_metric_set(self)
    __swig_destroy__ = _py_interop_run_metrics.delete_run_metrics
    __del__ = lambda self: None
run_metrics_swigregister = _py_interop_run_metrics.run_metrics_swigregister
run_metrics_swigregister(run_metrics)

# This file is compatible with both classic and new-style classes.


